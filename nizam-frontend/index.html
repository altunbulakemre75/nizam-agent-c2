<!doctype html>
<html lang="tr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>NIZAM COP</title>

  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />

  <style>
    html, body { height: 100%; margin: 0; }
    body { background:#0b0c10; color:#fff; font: 13px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    #map { height:100vh; width:100vw; position:relative; }

    #ui-panel{
      position:absolute; top:12px; left:12px; z-index:1200;
      width:330px; background:rgba(10,10,12,.72);
      border:1px solid rgba(255,255,255,.16);
      border-radius:14px; padding:12px; backdrop-filter: blur(6px);
      box-shadow:0 8px 30px rgba(0,0,0,.35);
    }
    #ui-panel .title{ font-weight:800; margin:0 0 10px 0; font-size:13px; opacity:.95; letter-spacing:.2px; }
    .row{ display:flex; align-items:center; justify-content:space-between; gap:10px; padding:9px 0; border-top:1px solid rgba(255,255,255,.08); }
    .row:first-of-type{ border-top:none; padding-top:0; }
    .label{ display:flex; flex-direction:column; gap:2px; min-width:150px; }
    .label .k{ font-weight:700; font-size:12px; opacity:.95; }
    .label .v{ font-size:12px; opacity:.70; overflow:hidden; text-overflow:ellipsis; }
    .badge{ font-size:11px; padding:4px 9px; border-radius:999px; border:1px solid rgba(255,255,255,.16); background:rgba(255,255,255,.06); white-space:nowrap; }
    .ok{ color:#a6ffcb; border-color:rgba(39,194,108,.40); background:rgba(39,194,108,.10); }
    .warn{ color:#ffd7a6; border-color:rgba(255,159,26,.40); background:rgba(255,159,26,.10); }
    .bad{ color:#ffb3ad; border-color:rgba(255,59,48,.40); background:rgba(255,59,48,.10); }

    .toggle{ display:inline-flex; align-items:center; gap:8px; user-select:none; }
    .toggle input{ transform:scale(1.1); }

    .slider-wrap{ display:flex; align-items:center; gap:10px; width:185px; }
    .slider-wrap input[type="range"]{ width:125px; }

    #threat-legend{
      position:absolute; right:12px; bottom:12px; z-index:1200; pointer-events:none;
      background:rgba(10,10,12,.70); border:1px solid rgba(255,255,255,.18);
      border-radius:12px; padding:10px 12px; min-width:200px; backdrop-filter: blur(6px);
      box-shadow:0 8px 30px rgba(0,0,0,.30);
    }
    #threat-legend .title{ font-weight:800; font-size:12px; margin:0 0 8px 0; opacity:.95; }
    #threat-legend .r{ display:flex; align-items:center; gap:8px; margin:6px 0; }
    #threat-legend .dot{ width:10px; height:10px; border-radius:999px; box-shadow:0 0 0 1px rgba(255,255,255,.25) inset; flex:0 0 10px; }
    #threat-legend .txt{ display:flex; justify-content:space-between; width:100%; gap:10px; opacity:.92; font-size:12px; }
    #threat-legend .rng{ opacity:.70; white-space:nowrap; }

    .leaflet-control-attribution{ opacity:.7; }

    /* =========================
       TRACK DETAIL PANEL (RIGHT)
       ========================= */
    #trackPanel{
      position:absolute;
      top:12px;
      right:12px;
      z-index:1300;
      width:340px;
      max-width: calc(100vw - 24px);
      background:rgba(10,10,12,.76);
      border:1px solid rgba(255,255,255,.16);
      border-radius:14px;
      padding:12px;
      backdrop-filter: blur(6px);
      box-shadow:0 8px 30px rgba(0,0,0,.35);
      display:none;
    }
    #trackPanelHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:10px;
    }
    #trackPanelTitle{
      margin:0;
      font-weight:800;
      font-size:13px;
      letter-spacing:.2px;
      opacity:.95;
    }
    #trackPanelClose{
      cursor:pointer;
      border:1px solid rgba(255,255,255,.16);
      background:rgba(255,255,255,.06);
      color:#fff;
      border-radius:999px;
      padding:4px 10px;
      font-size:11px;
      font-weight:700;
    }
    #trackPanelBody{ font-size:12px; line-height:1.45; }
    .kv{
      display:grid;
      grid-template-columns: 110px 1fr;
      gap:6px 10px;
      padding:8px 0;
      border-top:1px solid rgba(255,255,255,.08);
    }
    .kv:first-child{ border-top:none; padding-top:0; }
    .kv .k{ opacity:.72; font-weight:700; }
    .kv .v{ font-weight:700; word-break:break-word; }
    .muted{ opacity:.72; font-weight:600; }
    .reason{
      display:inline-block;
      margin:0 6px 6px 0;
      padding:3px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.16);
      background:rgba(255,255,255,.06);
      font-size:11px;
      font-weight:800;
      white-space:nowrap;
    }
  </style>
</head>

<body>
  <div id="map">
    <div id="ui-panel">
      <div class="title">NIZAM COP</div>

      <div class="row">
        <div class="label">
          <div class="k">WS</div>
          <div class="v" id="ws-url">ws://127.0.0.1:8000/ws</div>
        </div>
        <div class="badge bad" id="ws-badge">disconnected</div>
      </div>

      <div class="row">
        <div class="label">
          <div class="k">State</div>
          <div class="v" id="state-url">http://127.0.0.1:8000/api/state</div>
        </div>
        <div class="badge warn" id="state-badge">waiting</div>
      </div>

      <div class="row">
        <div class="label">
          <div class="k">Restricted Zone</div>
          <div class="v">Layer Control (UI only)</div>
        </div>
        <label class="toggle">
          <input type="checkbox" id="zone-toggle" />
          <span class="badge" id="zone-badge">OFF</span>
        </label>
      </div>

      <div class="row">
        <div class="label">
          <div class="k">Min Threat</div>
          <div class="v">Show ≥ <span id="minth-val">0</span></div>
        </div>
        <div class="slider-wrap">
          <input id="minth-slider" type="range" min="0" max="100" step="1" value="0">
          <span class="badge" id="minth-badge">0</span>
        </div>
      </div>

      <div class="row">
        <div class="label">
          <div class="k">Tracks (shown/total)</div>
          <div class="v">Marker + trail</div>
        </div>
        <div class="badge" id="track-count">0/0</div>
      </div>

      <!-- =========================
           D: Pause / Resume Control
           ========================= -->
      <div class="row">
        <div class="label">
          <div class="k">Stream</div>
          <div class="v">Pause / Resume</div>
        </div>
        <button id="pause-btn" class="badge warn" type="button">PAUSE</button>
      </div>
    </div>

    <!-- =========================
         TRACK DETAIL PANEL (RIGHT)
         ========================= -->
    <div id="trackPanel">
      <div id="trackPanelHeader">
        <h3 id="trackPanelTitle">Track Detail</h3>
        <button id="trackPanelClose" type="button">Close</button>
      </div>
      <div id="trackPanelBody"></div>
    </div>

    <!-- =========================
         D: PAUSED OVERLAY
         ========================= -->
    <div id="paused-overlay"
         style="display:none; position:absolute; inset:0; z-index:1100;
                background:rgba(0,0,0,.35); backdrop-filter: blur(2px);
                color:#fff; font-weight:800; letter-spacing:1px;
                align-items:center; justify-content:center;">
      <div style="padding:14px 22px; border-radius:12px;
                  background:rgba(10,10,12,.85);
                  border:1px solid rgba(255,255,255,.18);">
        PAUSED
      </div>
    </div>

    <div id="threat-legend">
      <div class="title">Threat Legend</div>
      <div class="r"><span class="dot" style="background:#27c26c"></span><div class="txt"><span>Low</span><span class="rng">0–29</span></div></div>
      <div class="r"><span class="dot" style="background:#ff9f1a"></span><div class="txt"><span>Medium</span><span class="rng">30–69</span></div></div>
      <div class="r"><span class="dot" style="background:#ff3b30"></span><div class="txt"><span>High</span><span class="rng">70+</span></div></div>
    </div>
  </div>

  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <script>
    // ================================
    // CONFIG
    // ================================
    const BACKEND_HTTP = "http://127.0.0.1:8000";
    const WS_URL = "ws://127.0.0.1:8000/ws";
    const STATE_URL = `${BACKEND_HTTP}/api/state`;

    // ================================
    // GLOBAL STATE (define early)
    // ================================
    const tracks = new Map(); // id -> {marker, trail, points, score, visible, meta}
    let zoneCircle = null;
    let lastZone = null;
    let ws = null;

    // ================================
    // UI elements
    // ================================
    const wsBadge = document.getElementById("ws-badge");
    const stateBadge = document.getElementById("state-badge");
    const zoneToggle = document.getElementById("zone-toggle");
    const zoneBadge = document.getElementById("zone-badge");
    const trackCountEl = document.getElementById("track-count");
    const minThSlider = document.getElementById("minth-slider");
    const minThValEl = document.getElementById("minth-val");
    const minThBadge = document.getElementById("minth-badge");

    document.getElementById("ws-url").textContent = WS_URL;
    document.getElementById("state-url").textContent = STATE_URL;

    // ================================
    // D: Pause / Resume (UI)
    // ================================
    let UI_PAUSED = false;
    const pauseBtn = document.getElementById("pause-btn");
    const pausedOverlay = document.getElementById("paused-overlay");

    function setPausedUI(on){
      UI_PAUSED = !!on;
      pauseBtn.textContent = on ? "RESUME" : "PAUSE";
      pauseBtn.className = "badge " + (on ? "ok" : "warn");
      pausedOverlay.style.display = on ? "flex" : "none";
    }

    // ================================
    // Track Detail Panel
    // ================================
    const trackPanelEl = document.getElementById("trackPanel");
    const trackPanelTitleEl = document.getElementById("trackPanelTitle");
    const trackPanelBodyEl = document.getElementById("trackPanelBody");
    const trackPanelCloseBtn = document.getElementById("trackPanelClose");

    let selectedTrackId = null;

    function setTrackPanelVisible(on){
      trackPanelEl.style.display = on ? "block" : "none";
      if (!on) selectedTrackId = null;
    }

    function threatBucket(score){
      const s = Number(score ?? 0);
      if (s >= 70) return "HIGH";
      if (s >= 30) return "MED";
      return "LOW";
    }

    function formatTs(ts){
      if (!ts) return "(unknown)";
      try{
        const d = new Date(ts);
        if (!isNaN(d.getTime())) return d.toLocaleString();
      } catch(_){}
      return String(ts);
    }

    function renderReasons(reasons){
      if (!reasons || (Array.isArray(reasons) && reasons.length === 0)){
        return '<span class="muted">(none)</span>';
      }
      if (Array.isArray(reasons)){
        return reasons.map(r => `<span class="reason">${String(r)}</span>`).join("");
      }
      return `<span class="reason">${String(reasons)}</span>`;
    }

    function openTrackPanel(trackId){
      const key = String(trackId);
      const t = tracks.get(key);
      if (!t) return;

      selectedTrackId = key;

      const m = t.meta || {};
      const id = m.id ?? key;
      const lat = Number(m.lat);
      const lon = Number(m.lon);
      const score = Number(m.threat_score ?? t.score ?? 0);
      const bucket = threatBucket(score);

      trackPanelTitleEl.textContent = `Track: ${id}`;

      trackPanelBodyEl.innerHTML = `
        <div class="kv">
          <div class="k">Threat</div>
          <div class="v">${score} <span class="muted">(${bucket})</span></div>
        </div>
        <div class="kv">
          <div class="k">Lat / Lon</div>
          <div class="v">${isFinite(lat) ? lat.toFixed(6) : "(n/a)"} , ${isFinite(lon) ? lon.toFixed(6) : "(n/a)"}</div>
        </div>
        <div class="kv">
          <div class="k">Last Update</div>
          <div class="v">${formatTs(m.last_update)}</div>
        </div>
        <div class="kv">
          <div class="k">Reasons</div>
          <div class="v">${renderReasons(m.reasons)}</div>
        </div>
      `;

      setTrackPanelVisible(true);
    }

    function refreshSelectedPanelIfNeeded(trackId){
      if (!selectedTrackId) return;
      if (String(trackId) !== selectedTrackId) return;
      openTrackPanel(trackId);
    }

    trackPanelCloseBtn.addEventListener("click", () => setTrackPanelVisible(false));

    // ================================
    // Map
    // ================================
    const map = L.map("map", { zoomControl: true }).setView([41.015, 28.979], 12);
    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 19,
      attribution: "&copy; OpenStreetMap contributors"
    }).addTo(map);

    // ================================
    // Badges
    // ================================
    function setWsBadge(state){
      if (state === "connected") { wsBadge.textContent="connected"; wsBadge.className="badge ok"; return; }
      if (state === "connecting") { wsBadge.textContent="connecting"; wsBadge.className="badge warn"; return; }
      wsBadge.textContent="disconnected"; wsBadge.className="badge bad";
    }

    // ================================
    // Threat
    // ================================
    function threatColor(score){
      const s = Number(score ?? 0);
      if (s >= 70) return "#ff3b30";
      if (s >= 30) return "#ff9f1a";
      return "#27c26c";
    }

    // ================================
    // Zone toggle
    // ================================
    function getZoneToggleState(){
      const v = localStorage.getItem("nizam.zone.enabled");
      return v === null ? true : v === "1";
    }
    function setZoneToggleUI(on){
      zoneToggle.checked = !!on;
      zoneBadge.textContent = on ? "ON" : "OFF";
      zoneBadge.className = "badge " + (on ? "ok" : "");
    }
    function setZoneToggleState(on){
      localStorage.setItem("nizam.zone.enabled", on ? "1" : "0");
      setZoneToggleUI(on);
      renderZone(lastZone);
    }
    zoneToggle.addEventListener("change", () => setZoneToggleState(zoneToggle.checked));

    function renderZone(zone){
      lastZone = zone || null;

      if (!getZoneToggleState()){
        if (zoneCircle){ map.removeLayer(zoneCircle); zoneCircle = null; }
        return;
      }
      if (!zone || zone.lat == null || zone.lon == null || zone.r_m == null){
        if (zoneCircle){ map.removeLayer(zoneCircle); zoneCircle = null; }
        return;
      }

      const latlng = [Number(zone.lat), Number(zone.lon)];
      const r = Number(zone.r_m);

      if (!zoneCircle){
        zoneCircle = L.circle(latlng, {
          radius: r,
          color: "#ff3b30",
          weight: 2,
          fillColor: "#ff3b30",
          fillOpacity: 0.12
        }).addTo(map);
      } else {
        zoneCircle.setLatLng(latlng);
        zoneCircle.setRadius(r);
      }
    }

    // ================================
    // Min threat
    // ================================
    function getMinThreat(){
      const v = localStorage.getItem("nizam.minthreat");
      return v === null ? 0 : Math.max(0, Math.min(100, Number(v)));
    }
    function setMinThreat(v){
      const n = Math.max(0, Math.min(100, Number(v)));
      localStorage.setItem("nizam.minthreat", String(n));
      minThSlider.value = String(n);
      minThValEl.textContent = String(n);
      minThBadge.textContent = String(n);
      applyMinThreatFilter();
    }
    function shouldShowScore(score){
      return Number(score ?? 0) >= getMinThreat();
    }

    // ================================
    // Tracks
    // ================================
    function refreshTrackCounter(){
      let shown = 0;
      for (const [,t] of tracks.entries()) if (t.visible) shown++;
      trackCountEl.textContent = `${shown}/${tracks.size}`;
    }

    function setTrackVisible(t, visible){
      t.visible = !!visible;
      const markerOnMap = map.hasLayer(t.marker);
      const trailOnMap = map.hasLayer(t.trail);

      if (t.visible){
        if (!markerOnMap) t.marker.addTo(map);
        if (!trailOnMap) t.trail.addTo(map);
      } else {
        if (markerOnMap) map.removeLayer(t.marker);
        if (trailOnMap) map.removeLayer(t.trail);
      }
    }

    function applyMinThreatFilter(){
      for (const [,t] of tracks.entries()){
        setTrackVisible(t, shouldShowScore(t.score));
      }
      refreshTrackCounter();
    }

    function upsertTrack(id, lat, lon, score, meta){
      if (id == null || lat == null || lon == null) return;

      const key = String(id);
      const latlng = [Number(lat), Number(lon)];
      const s = Number(score ?? 0);
      const color = threatColor(s);

      let t = tracks.get(key);
      if (!t){
        const marker = L.circleMarker(latlng, {
          radius: 7,
          color,
          weight: 2,
          fillColor: color,
          fillOpacity: 0.85
        });

        // click -> open panel
        marker.on("click", () => openTrackPanel(key));

        const trail = L.polyline([latlng], { color, weight: 2, opacity: 0.75 });

        t = { marker, trail, points: [latlng], score: s, visible: false, meta: {} };

        // store meta (best-effort)
        t.meta = {
          id: key,
          lat: Number(lat),
          lon: Number(lon),
          threat_score: s,
          last_update: meta?.last_update ?? meta?.ts ?? meta?.timestamp ?? new Date().toISOString(),
          reasons: meta?.reasons ?? null
        };

        tracks.set(key, t);
      } else {
        t.points.push(latlng);
        if (t.points.length > 60) t.points.shift();

        t.marker.setLatLng(latlng);
        t.marker.setStyle({ color, fillColor: color });

        t.trail.setLatLngs(t.points);
        t.trail.setStyle({ color });

        t.score = s;

        // update meta (best-effort)
        t.meta = {
          ...(t.meta || {}),
          id: key,
          lat: Number(lat),
          lon: Number(lon),
          threat_score: s,
          last_update: meta?.last_update ?? meta?.ts ?? meta?.timestamp ?? t.meta?.last_update ?? new Date().toISOString(),
          reasons: meta?.reasons ?? t.meta?.reasons ?? null
        };
      }

      setTrackVisible(t, shouldShowScore(t.score));
      refreshTrackCounter();

      // keep panel live if selected
      refreshSelectedPanelIfNeeded(key);
    }

    // ================================
    // Message parsing (robust)
    // ================================
    function parseTrackFromMessage(msg){
      // supports:
      // 1) {event_type:"cop.track", payload:{id,lat,lon,threat_score,reasons,last_update}}
      // 2) {event_type:"cop.track", id,lat,lon, threat:{score}}
      const p = (msg && typeof msg === "object" && msg.payload && typeof msg.payload === "object")
        ? msg.payload
        : msg;

      const id = p?.id;
      const lat = p?.lat;
      const lon = p?.lon;

      const score = p?.threat_score ?? p?.score ?? p?.threat?.score ?? 0;
      return { id, lat, lon, score, meta: p };
    }

    function handleSnapshot(msg){
      // zone_circle (senin /api/state formatın)
      if (msg.zone_circle && msg.zone_circle.lat != null && msg.zone_circle.lon != null){
        renderZone({ lat: msg.zone_circle.lat, lon: msg.zone_circle.lon, r_m: msg.zone_circle.r_m });
      }
      // zone (alternatif format)
      if (msg.zone && msg.zone.lat != null && msg.zone.lon != null){
        renderZone({ lat: msg.zone.lat, lon: msg.zone.lon, r_m: msg.zone.r_m });
      }
      // tracks
      if (msg.tracks && typeof msg.tracks === "object"){
        for (const [id, t] of Object.entries(msg.tracks)){
          const score = t?.threat?.score ?? t?.threat_score ?? t?.score ?? 0;
          // snapshot formatında reasons/last_update yoksa da sorun değil
          upsertTrack(id, t?.lat, t?.lon, score, t);
        }
      }
    }

    // ================================
    // WebSocket
    // ================================
    function connectWS(){
      try{
        setWsBadge("connecting");
        ws = new WebSocket(WS_URL);

        ws.onopen = () => setWsBadge("connected");

        ws.onclose = () => {
          setWsBadge("disconnected");
          setTimeout(connectWS, 1200);
        };

        ws.onerror = () => {
          setWsBadge("disconnected");
        };

        ws.onmessage = (ev) => {
          try{
            const msg = JSON.parse(ev.data);
            const type = msg?.event_type ?? msg?.type;

            if (type === "cop.snapshot"){ handleSnapshot(msg); return; }

            if (type === "cop.track"){
              // D: UI paused -> ignore track updates
              if (UI_PAUSED) return;

              const t = parseTrackFromMessage(msg);
              upsertTrack(t.id, t.lat, t.lon, t.score, t.meta);
              return;
            }

            if (type === "cop.zone"){
              const z = msg.payload || msg;
              renderZone({ lat: z.lat, lon: z.lon, r_m: z.r_m });
              return;
            }
          } catch(_){}
        };
      } catch(_){
        setWsBadge("disconnected");
        setTimeout(connectWS, 1500);
      }
    }

    // ================================
    // D: Pause/Resume button -> backend
    // ================================
    pauseBtn.addEventListener("click", async () => {
      try{
        if (!UI_PAUSED){
          const res = await fetch(`${BACKEND_HTTP}/api/pause`, { method:"POST" });
          if (!res.ok) throw new Error("pause http " + res.status);
          setPausedUI(true);
        } else {
          const res = await fetch(`${BACKEND_HTTP}/api/resume`, { method:"POST" });
          if (!res.ok) throw new Error("resume http " + res.status);
          setPausedUI(false);
        }
      } catch(e){
        console.error("pause/resume failed", e);
      }
    });

    // ================================
    // State polling (health only)
    // ================================
    let lastStateOkAt = 0;

    async function pollState(){
      try{
        const res = await fetch(STATE_URL, { cache:"no-store" });
        if (!res.ok) throw new Error("state http " + res.status);
        await res.json();
        lastStateOkAt = Date.now();
        stateBadge.textContent = "ok";
        stateBadge.className = "badge ok";
      } catch(_){
        const age = Date.now() - lastStateOkAt;
        stateBadge.textContent = age < 5000 ? "stale" : "down";
        stateBadge.className = "badge " + (age < 5000 ? "warn" : "bad");
      } finally {
        setTimeout(pollState, 900);
      }
    }

    // ================================
    // INIT (order matters)
    // ================================
    setZoneToggleUI(getZoneToggleState());

    minThSlider.addEventListener("input", () => setMinThreat(minThSlider.value));
    setMinThreat(getMinThreat());     // init slider + filter
    applyMinThreatFilter();           // safe, tracks exists

    // default UI paused off
    setPausedUI(false);

    connectWS();
    pollState();
  </script>
</body>
</html>
